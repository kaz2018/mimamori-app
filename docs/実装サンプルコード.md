# Gemini ADK & Vertex AI 実装サンプルコード

## 🚀 Cloud Functions 実装

### 1. Gemini ADK でのストーリー生成

```python
# functions/story_generation.py
import functions_framework
import vertexai
from vertexai.generative_models import GenerativeModel
import json
import re

# Vertex AI 初期化
vertexai.init(project="your-project-id", location="us-central1")

@functions_framework.http
def generate_story(request):
    """Gemini ADKを使用してストーリー生成"""
    
    # CORS ヘッダー設定
    headers = {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'POST',
        'Access-Control-Allow-Headers': 'Content-Type',
    }
    
    if request.method == 'OPTIONS':
        return ('', 204, headers)
    
    try:
        # リクエストデータ取得
        request_json = request.get_json()
        user_topic = request_json.get('topic', '冒険')
        
        # Gemini Pro モデル初期化
        model = GenerativeModel("gemini-1.5-pro")
        
        # プロンプト作成
        prompt = create_story_prompt(user_topic)
        
        # ストーリー生成
        response = model.generate_content(
            prompt,
            generation_config={
                "temperature": 0.8,
                "top_p": 0.8,
                "top_k": 40,
                "max_output_tokens": 2048,
            }
        )
        
        # レスポンス解析
        story_data = parse_story_response(response.text)
        
        return (json.dumps(story_data, ensure_ascii=False), 200, headers)
        
    except Exception as e:
        error_response = {
            'error': str(e),
            'fallback_story': get_fallback_story(user_topic)
        }
        return (json.dumps(error_response, ensure_ascii=False), 500, headers)

def create_story_prompt(user_topic):
    """ストーリー生成プロンプトを作成"""
    
    return f"""
あなたは幼稚園児（3-6歳）向けの物語作家です。以下の条件で物語を作成してください：

【お題】{user_topic}

【条件】
- 対象年齢：3-6歳（ひらがな多め、優しい表現）
- 構造：導入 → 2択分岐 → 2択分岐 → 4つの結末
- 全結末：必ずハッピーエンド
- 各段落：50-80文字程度
- 教育的価値：友情、優しさ、勇気、協力などのテーマ
- 安全性：怖い要素なし、年齢適正な内容

【出力形式】
JSON形式で以下の構造で出力してください：

```json
{{
  "title": "物語のタイトル",
  "introduction": "導入部分のテキスト（主人公紹介と状況設定）",
  "first_choice": {{
    "situation": "最初の選択場面の説明",
    "option_a": "選択肢A（絵文字付き）",
    "option_b": "選択肢B（絵文字付き）"
  }},
  "branches": {{
    "a": {{
      "story": "選択肢Aを選んだ場合の展開",
      "second_choice": {{
        "situation": "2回目の選択場面の説明",
        "option_a": "選択肢A-A（絵文字付き）",
        "option_b": "選択肢A-B（絵文字付き）"
      }}
    }},
    "b": {{
      "story": "選択肢Bを選んだ場合の展開",
      "second_choice": {{
        "situation": "2回目の選択場面の説明",
        "option_a": "選択肢B-A（絵文字付き）",
        "option_b": "選択肢B-B（絵文字付き）"
      }}
    }}
  }},
  "endings": {{
    "aa": {{
      "story": "結末A-A（ハッピーエンド、学びのある結論）",
      "lesson": "この結末から学べること",
      "image_prompt": "A happy children's book illustration showing [具体的な場面描写 in English]"
    }},
    "ab": {{
      "story": "結末A-B（ハッピーエンド、学びのある結論）",
      "lesson": "この結末から学べること",
      "image_prompt": "A joyful children's book scene depicting [具体的な場面描写 in English]"
    }},
    "ba": {{
      "story": "結末B-A（ハッピーエンド、学びのある結論）",
      "lesson": "この結末から学べること",
      "image_prompt": "A cheerful children's illustration featuring [具体的な場面描写 in English]"
    }},
    "bb": {{
      "story": "結末B-B（ハッピーエンド、学びのある結論）",
      "lesson": "この結末から学べること",
      "image_prompt": "A delightful children's book image showing [具体的な場面描写 in English]"
    }}
  }}
}}
```

重要：必ずJSONのみを出力し、余計なテキストは含めないでください。
"""

def parse_story_response(response_text):
    """Geminiのレスポンスを解析してJSONデータを抽出"""
    
    try:
        # JSONブロックを抽出
        json_match = re.search(r'```json\s*(\{.*?\})\s*```', response_text, re.DOTALL)
        if json_match:
            json_str = json_match.group(1)
        else:
            # バックアップ: 全体をJSONとして解析試行
            json_str = response_text.strip()
        
        # JSON解析
        story_data = json.loads(json_str)
        
        # データ検証
        validate_story_data(story_data)
        
        return story_data
        
    except Exception as e:
        print(f"JSON解析エラー: {e}")
        raise Exception(f"ストーリーデータの解析に失敗しました: {e}")

def validate_story_data(story_data):
    """生成されたストーリーデータを検証"""
    
    required_keys = ['title', 'introduction', 'first_choice', 'branches', 'endings']
    
    for key in required_keys:
        if key not in story_data:
            raise Exception(f"必須キー '{key}' が見つかりません")
    
    # 分岐数検証
    if len(story_data['branches']) != 2:
        raise Exception("分岐は2つである必要があります")
    
    # 結末数検証
    if len(story_data['endings']) != 4:
        raise Exception("結末は4つである必要があります")
    
    # 画像プロンプト存在確認
    for ending_key, ending_data in story_data['endings'].items():
        if 'image_prompt' not in ending_data:
            raise Exception(f"結末 {ending_key} に画像プロンプトがありません")

def get_fallback_story(user_topic):
    """エラー時のフォールバックストーリー"""
    
    return {
        "title": f"{user_topic}のお話",
        "introduction": "素敵な冒険が始まります。",
        "first_choice": {
            "situation": "どちらの道を選びますか？",
            "option_a": "🌸 明るい道",
            "option_b": "🌟 不思議な道"
        },
        "branches": {
            "a": {
                "story": "明るい道では新しい友達に出会いました。",
                "second_choice": {
                    "situation": "友達と何をしますか？",
                    "option_a": "🎈 一緒に遊ぶ",
                    "option_b": "🍭 おやつを分ける"
                }
            },
            "b": {
                "story": "不思議な道では魔法の光を見つけました。",
                "second_choice": {
                    "situation": "光をどうしますか？",
                    "option_a": "✨ 光を集める",
                    "option_b": "🌙 光と話す"
                }
            }
        },
        "endings": {
            "aa": {
                "story": "友達と楽しく遊んで、みんなで笑顔になりました。",
                "lesson": "友情の大切さ",
                "image_prompt": "Children playing happily together in a bright meadow"
            },
            "ab": {
                "story": "優しくおやつを分けて、みんなが嬉しくなりました。",
                "lesson": "分け合うことの喜び",
                "image_prompt": "Children sharing snacks under a beautiful tree"
            },
            "ba": {
                "story": "光を集めて素敵な虹を作り、世界が明るくなりました。",
                "lesson": "努力することの価値",
                "image_prompt": "A magical rainbow created by gathering starlight"
            },
            "bb": {
                "story": "光と話して秘密を知り、賢くなりました。",
                "lesson": "学ぶことの楽しさ",
                "image_prompt": "A child talking to magical glowing lights in the forest"
            }
        }
    }
```

### 2. Vertex AI Imagen での画像生成

```python
# functions/image_generation.py
import functions_framework
import vertexai
from vertexai.preview.vision_models import ImageGenerationModel
from google.cloud import storage
import uuid
import json
import asyncio
import concurrent.futures

# Vertex AI 初期化
vertexai.init(project="your-project-id", location="us-central1")

@functions_framework.http
def generate_story_images(request):
    """4つの結末画像を並行生成"""
    
    headers = {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'POST',
        'Access-Control-Allow-Headers': 'Content-Type',
    }
    
    if request.method == 'OPTIONS':
        return ('', 204, headers)
    
    try:
        request_json = request.get_json()
        story_data = request_json.get('story_data')
        session_id = request_json.get('session_id', str(uuid.uuid4()))
        
        # 並行画像生成
        image_results = generate_all_images_parallel(story_data, session_id)
        
        response = {
            'status': 'success',
            'session_id': session_id,
            'images': image_results
        }
        
        return (json.dumps(response), 200, headers)
        
    except Exception as e:
        error_response = {
            'status': 'error',
            'message': str(e),
            'fallback_images': get_fallback_images()
        }
        return (json.dumps(error_response), 500, headers)

def generate_all_images_parallel(story_data, session_id):
    """4つの画像を並行生成"""
    
    endings = story_data.get('endings', {})
    
    # 並行実行のためのエグゼキューター
    with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:
        # 各結末の画像生成タスクを作成
        future_to_ending = {}
        
        for ending_key, ending_data in endings.items():
            future = executor.submit(
                generate_single_image,
                ending_key,
                ending_data.get('image_prompt', ''),
                session_id
            )
            future_to_ending[future] = ending_key
        
        # 結果を収集
        results = {}
        for future in concurrent.futures.as_completed(future_to_ending):
            ending_key = future_to_ending[future]
            try:
                image_url = future.result(timeout=60)  # 60秒タイムアウト
                results[ending_key] = {
                    'status': 'success',
                    'image_url': image_url
                }
            except Exception as e:
                print(f"画像生成エラー ({ending_key}): {e}")
                results[ending_key] = {
                    'status': 'error',
                    'error': str(e),
                    'fallback_url': get_fallback_image_url(ending_key)
                }
        
        return results

def generate_single_image(ending_key, base_prompt, session_id):
    """単一の画像を生成"""
    
    try:
        # Imagen モデル初期化
        model = ImageGenerationModel.from_pretrained("imagegeneration@006")
        
        # プロンプト最適化
        optimized_prompt = optimize_image_prompt(base_prompt)
        
        # 画像生成
        images = model.generate_images(
            prompt=optimized_prompt,
            number_of_images=1,
            aspect_ratio="4:3",
            safety_filter_level="block_most",
            person_generation="allow_adult"
        )
        
        if not images.images:
            raise Exception("画像生成に失敗しました")
        
        # Cloud Storage に保存
        image_url = save_image_to_storage(
            images.images[0], 
            session_id, 
            ending_key
        )
        
        return image_url
        
    except Exception as e:
        print(f"画像生成エラー: {e}")
        raise

def optimize_image_prompt(base_prompt):
    """幼稚園児向け絵本の画像プロンプトを最適化"""
    
    style_prefix = """
    Children's book illustration, watercolor style, soft pastel colors,
    friendly cartoon characters, warm and cozy atmosphere, 
    professional children's book quality, hand-drawn feel,
    """
    
    character_style = """
    Characters with big friendly eyes, round faces, simple design,
    expressive but not overly detailed, cute and approachable,
    """
    
    safety_guidelines = """
    G-rated content appropriate for ages 3-6, no scary elements, 
    no violence, no dark themes, bright and cheerful mood,
    educational and wholesome content, encouraging atmosphere,
    """
    
    technical_specs = """
    High quality digital art, clean composition, balanced colors,
    suitable for children's book printing, vibrant but not overwhelming,
    """
    
    optimized_prompt = f"{style_prefix} {character_style} {base_prompt} {safety_guidelines} {technical_specs}"
    
    # プロンプト長制限
    if len(optimized_prompt) > 1000:
        optimized_prompt = optimized_prompt[:950] + "..."
    
    return optimized_prompt

def save_image_to_storage(image, session_id, ending_key):
    """生成画像をCloud Storageに保存"""
    
    try:
        # Cloud Storage クライアント
        client = storage.Client()
        bucket = client.bucket("your-storybook-images")
        
        # ファイル名生成
        filename = f"story_{session_id}_{ending_key}_{uuid.uuid4().hex[:8]}.png"
        blob_path = f"generated_images/{filename}"
        
        # アップロード
        blob = bucket.blob(blob_path)
        blob.upload_from_string(
            image._image_bytes,
            content_type='image/png'
        )
        
        # 公開URL設定
        blob.make_public()
        public_url = blob.public_url
        
        print(f"画像保存完了: {public_url}")
        return public_url
        
    except Exception as e:
        print(f"画像保存エラー: {e}")
        raise Exception(f"画像の保存に失敗しました: {e}")

def get_fallback_images():
    """フォールバック画像URL"""
    
    return {
        'aa': 'https://storage.googleapis.com/your-storybook-images/fallback/happy_ending_1.png',
        'ab': 'https://storage.googleapis.com/your-storybook-images/fallback/happy_ending_2.png',
        'ba': 'https://storage.googleapis.com/your-storybook-images/fallback/happy_ending_3.png',
        'bb': 'https://storage.googleapis.com/your-storybook-images/fallback/happy_ending_4.png'
    }

def get_fallback_image_url(ending_key):
    """特定の結末のフォールバック画像"""
    
    fallback_images = get_fallback_images()
    return fallback_images.get(ending_key, fallback_images['aa'])
```

### 3. 効率的な並行処理システム

```python
# functions/story_orchestrator.py
import functions_framework
import asyncio
import aiohttp
import json
from concurrent.futures import ThreadPoolExecutor
import time

@functions_framework.http
def create_complete_storybook(request):
    """ストーリー生成と画像生成を並行実行"""
    
    headers = {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'POST',
        'Access-Control-Allow-Headers': 'Content-Type',
    }
    
    if request.method == 'OPTIONS':
        return ('', 204, headers)
    
    try:
        request_json = request.get_json()
        user_topic = request_json.get('topic')
        
        # 並行処理で効率的な絵本作成
        result = run_parallel_storybook_creation(user_topic)
        
        return (json.dumps(result, ensure_ascii=False), 200, headers)
        
    except Exception as e:
        error_response = {
            'status': 'error',
            'message': str(e)
        }
        return (json.dumps(error_response), 500, headers)

def run_parallel_storybook_creation(user_topic):
    """並行処理でストーリーブック作成"""
    
    start_time = time.time()
    
    # Step 1: ストーリー生成（優先実行）
    print("📖 ストーリー生成開始...")
    story_data = generate_story_sync(user_topic)
    story_time = time.time()
    
    # Step 2: ストーリー完成と同時に画像生成開始
    print("🎨 画像生成開始...")
    with ThreadPoolExecutor(max_workers=4) as executor:
        image_futures = {}
        
        for ending_key, ending_data in story_data['endings'].items():
            future = executor.submit(
                generate_image_sync,
                ending_key,
                ending_data['image_prompt']
            )
            image_futures[ending_key] = future
        
        # 画像生成完了を待機
        image_results = {}
        for ending_key, future in image_futures.items():
            try:
                image_url = future.result(timeout=45)  # 45秒制限
                image_results[ending_key] = {
                    'status': 'success',
                    'url': image_url
                }
                print(f"✅ 画像完成: {ending_key}")
            except Exception as e:
                print(f"❌ 画像生成失敗: {ending_key} - {e}")
                image_results[ending_key] = {
                    'status': 'error',
                    'fallback_url': get_fallback_image_url(ending_key)
                }
    
    total_time = time.time() - start_time
    
    return {
        'status': 'success',
        'story_data': story_data,
        'images': image_results,
        'performance': {
            'story_generation_time': round(story_time - start_time, 2),
            'total_time': round(total_time, 2),
            'parallel_efficiency': True
        }
    }

# プログレス追跡システム
class ProgressTracker:
    def __init__(self):
        self.progress = {
            'story': 0,
            'images': {'aa': 0, 'ab': 0, 'ba': 0, 'bb': 0}
        }
    
    def update_story_progress(self, percentage):
        self.progress['story'] = percentage
        self.notify_client()
    
    def update_image_progress(self, ending_key, percentage):
        self.progress['images'][ending_key] = percentage
        self.notify_client()
    
    def notify_client(self):
        # WebSocket または Server-Sent Events で進捗通知
        # 実装はクライアント要件に応じて
        pass
```

## 🖥️ フロントエンド実装

### 4. React/TypeScript での統合

```typescript
// hooks/useAIStorybook.ts
import { useState, useEffect } from 'react';

interface StoryData {
  title: string;
  introduction: string;
  first_choice: Choice;
  branches: { [key: string]: Branch };
  endings: { [key: string]: Ending };
}

interface Choice {
  situation: string;
  option_a: string;
  option_b: string;
}

interface Branch {
  story: string;
  second_choice: Choice;
}

interface Ending {
  story: string;
  lesson: string;
  image_prompt: string;
}

interface ImageResult {
  status: 'generating' | 'completed' | 'error';
  url?: string;
  progress: number;
}

export const useAIStorybook = () => {
  const [storyData, setStoryData] = useState<StoryData | null>(null);
  const [images, setImages] = useState<{ [key: string]: ImageResult }>({});
  const [isGenerating, setIsGenerating] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const createStorybook = async (topic: string) => {
    setIsGenerating(true);
    setError(null);
    
    try {
      // Step 1: ストーリー生成
      const storyResponse = await fetch('/api/generate-story', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ topic })
      });
      
      if (!storyResponse.ok) {
        throw new Error('ストーリー生成に失敗しました');
      }
      
      const storyData = await storyResponse.json();
      setStoryData(storyData);
      
      // Step 2: 画像生成を並行開始
      generateImagesInBackground(storyData);
      
    } catch (err) {
      setError(err instanceof Error ? err.message : '予期しないエラーが発生しました');
    } finally {
      setIsGenerating(false);
    }
  };

  const generateImagesInBackground = async (storyData: StoryData) => {
    const endings = Object.keys(storyData.endings);
    
    // 初期化
    const initialImages = endings.reduce((acc, key) => ({
      ...acc,
      [key]: { status: 'generating' as const, progress: 0 }
    }), {});
    setImages(initialImages);
    
    // 並行画像生成
    const imagePromises = endings.map(async (endingKey) => {
      try {
        const response = await fetch('/api/generate-image', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            ending_key: endingKey,
            prompt: storyData.endings[endingKey].image_prompt
          })
        });
        
        if (!response.ok) {
          throw new Error('画像生成に失敗しました');
        }
        
        const result = await response.json();
        
        setImages(prev => ({
          ...prev,
          [endingKey]: {
            status: 'completed',
            url: result.image_url,
            progress: 100
          }
        }));
        
      } catch (error) {
        console.error(`画像生成エラー (${endingKey}):`, error);
        setImages(prev => ({
          ...prev,
          [endingKey]: {
            status: 'error',
            progress: 100
          }
        }));
      }
    });
    
    // プログレス更新をシミュレート
    simulateImageProgress(endings);
    
    await Promise.allSettled(imagePromises);
  };

  const simulateImageProgress = (endings: string[]) => {
    endings.forEach(endingKey => {
      let progress = 0;
      const interval = setInterval(() => {
        progress += Math.random() * 15 + 5;
        
        if (progress >= 95) {
          clearInterval(interval);
          return;
        }
        
        setImages(prev => ({
          ...prev,
          [endingKey]: {
            ...prev[endingKey],
            progress: Math.min(progress, 95)
          }
        }));
      }, 500);
    });
  };

  return {
    storyData,
    images,
    isGenerating,
    error,
    createStorybook
  };
};
```

### 5. Vue.js Composition API 実装

```typescript
// composables/useAIStorybook.ts
import { ref, reactive } from 'vue';

export const useAIStorybook = () => {
  const storyData = ref(null);
  const images = reactive({});
  const isGenerating = ref(false);
  const error = ref(null);
  
  const createStorybook = async (topic: string) => {
    isGenerating.value = true;
    error.value = null;
    
    try {
      // ストーリー生成と画像生成の並行処理
      const [storyResult] = await Promise.all([
        generateStory(topic),
        // 画像生成は非同期で開始
        new Promise(resolve => {
          setTimeout(() => {
            generateImages().then(resolve);
          }, 1000);
        })
      ]);
      
      storyData.value = storyResult;
      
    } catch (err) {
      error.value = err.message;
    } finally {
      isGenerating.value = false;
    }
  };
  
  const generateStory = async (topic: string) => {
    const response = await fetch('/api/story-generation', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ topic })
    });
    
    return response.json();
  };
  
  const generateImages = async () => {
    if (!storyData.value) return;
    
    const endings = Object.keys(storyData.value.endings);
    
    endpoints.forEach(async (ending) => {
      images[ending] = { status: 'generating', progress: 0 };
      
      try {
        const imageUrl = await generateSingleImage(ending);
        images[ending] = { status: 'completed', url: imageUrl, progress: 100 };
      } catch (error) {
        images[ending] = { status: 'error', progress: 100 };
      }
    });
  };
  
  return {
    storyData,
    images,
    isGenerating,
    error,
    createStorybook
  };
};
```

このシステムにより、Gemini ADKで高品質なストーリーを生成し、Vertex AIで美しい画像を並行作成することで、子供たちが待つことなく楽しめる効率的な絵本作成システムを実現できます！
